<html>
  <body>
<pre>
hue = {<br>
'A': 10,<br>
'B': 8,<br>
'C': 5,<br>
'D': 7,<br>
'E': 3,<br>
'F': 6,<br>
'G': 5,<br>
'H': 3,<br>
'I': 1,<br>
'J': 0<br>
}<br>
<br>
graph = {<br>
    'A': [('B', 6), ('F', 3)],<br>
 'B': [('C', 3), ('D', 2)],<br>
 'C': [('D', 1), ('E', 5)],<br>
 'D': [('C', 1), ('E', 8)],<br>
 'E': [('I', 5), ('J', 5)],<br>
 'F': [('G', 1),('H', 7)],<br>
 'G': [('I', 3)],<br>
 'H': [('I', 2)],<br>
 'I': [('E', 5), ('J', 3)],<br>
}<br>
<br>
start = 'A'<br>
stop = 'J'<br>
path = list(start)<br>
<br>
def func():<br>
    mx = 999<br>
    nxt = ' '<br>
    if path[-1] not in graph:<br>
        print("Path not found")<br>
        exit()<br>
    for reach in graph[path[-1]]:<br>
        if (reach[1]+hue[reach[0]] < mx) and (reach[0] not in path):<br>
            nxt = reach[0]<br>
            mx = reach[1]+hue[reach[0]]<br>
    if nxt in path or nxt == ' ':<br>
        print("Path not found")<br>
        exit()<br>
    path.append(nxt)<br>
    #print(nxt)<br>
<br>
while stop not in path:<br>
    func()<br>
print("Path found", path)<br>

    
<br>
          2<br>
          
class Graph:<br>
    def __init__(self, graph, h, start):<br>
        self.graph, self.h, self.start = graph, h, start<br>
        self.parent, self.solution_graph = {}, {}<br>
<br>
    def apply_ao_star(self, v=None):<br>
        v = v or self.start<br>
        print("HEURISTIC VALUES:",self.h)<br>
        print("SOLUTION GRAPH:",self.solution_graph)<br>
        print("Processing node:",v)<br>
        print('-' * 50)<br>
        min_cost, child_node_list = self.compute_minimum_cost_child_nodes(v)<br>
<br>
        if min_cost is not None: self.h[v], self.solution_graph[v] = min_cost, child_node_list<br>
        if v in self.parent: self.apply_ao_star(self.parent[v])<br>
        [self.apply_ao_star(c) for c in child_node_list]<br>
<br>
    def compute_minimum_cost_child_nodes(self, v):<br>
        min_cost, child_node_list = float('inf'), []<br>
<br>
        for node_info_list in self.graph.get(v, ''):<br>
            cost = sum(self.h[c] + w for c, w in node_info_list)<br>
            if cost < min_cost: min_cost, child_node_list = cost, [c for c, _ in node_info_list]<br>
<br>
        return min_cost if min_cost != float('inf') else None, child_node_list<br>
<br>
h1 = {'A': 1, 'B': 6, 'C': 2, 'D': 12, 'E': 2, 'F': 1, 'G': 5, 'H': 7, 'I': 7, 'J': 1}<br>
graph1 = {<br>
    'A': [[('B', 1), ('C', 1)], [('D', 1)]],<br>
    'B': [[('G', 1)], [('H', 1)]],<br>
    'C': [[('J', 1)]],<br>
    'D': [[('E', 1), ('F', 1)]],<br>
    'G': [[('I', 1)]]<br>
}<br>

G1 = Graph(graph1, h1, 'A')<br>
G1.apply_ao_star()<br>
print(f"FOR GRAPH SOLUTION, TRAVERSE THE GRAPH FROM THE STARTNODE: {G1.start}\n{'-' * 50}\n{G1.solution_graph}\n{'-' * 50}")<br>

            
3.
import numpy as np
import pandas as pd
data=pd.read_csv('./p3(gpt).txt')
print(data)
conditions=np.array(data.iloc[:, 0:-1])
print("Instances are:\n", conditions)
target=np.array(data.iloc[:, -1])
print("\nFinal Target Values are: ",target,"\n")

def eliminate(conditions, target):
    print("Initialization of general and specific Boundaries: ")
    specific=conditions[0].copy()
    general=[]
    print(specific,general)
    for i,c in enumerate(conditions):
        print("For Instance ",i+1)
        if(target[i]=="yes"):
            print("The instance",c, "is positive")
            for x in range(len(c)):
                if specific[x]!=c[x]:
                    specific[x]="?"
        else:
            print("The instance",c ,"is negative")
            for x in range(len(c)):
                if c[x]!=specific[x] and specific[x]!="?":
                    l=["?" for i in range(len(c))]
                    l[x]=specific[x]
                    general.append(l)
        print(specific, general)
       
    for i in range(len(general)):
            for j in range(len(general[0])):
                if general[i][j]!="?" and general[i][j] not in specific:
                    general[i][j]='?'
   
   
    return specific, general

specific_hypothesis, general_hypothesis=eliminate(conditions, target)
print("Specific Hypothesis: ",specific_hypothesis,"\nGeneral Hypthesis: ",general_hypothesis)


5.
import numpy as np

X = np.array([[2, 9], [1, 5], [3, 6]], dtype=float)
y = np.array([[92], [86], [89]], dtype=float)
X /= np.amax(X, axis=0)
y /= 100

input_neurons, hidden_neurons, output_neurons = 2, 3, 1
epochs, lr = 5000, 0.1

wh, bh = np.random.uniform(size=(input_neurons, hidden_neurons)), np.random.uniform(size=(1, hidden_neurons))
wout, bout = np.random.uniform(size=(hidden_neurons, output_neurons)), np.random.uniform(size=(1, output_neurons))

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
    return x * (1 - x)

for epoch in range(epochs):
    hlayer_input = np.dot(X, wh) + bh
    hlayer_activation = sigmoid(hlayer_input)
    output_input = np.dot(hlayer_activation, wout) + bout
    predicted_output = sigmoid(output_input)

    output_error = y - predicted_output
    output_gradient = sigmoid_derivative(predicted_output)
    output_delta = output_error * output_gradient
    hidden_layer_error = output_delta.dot(wout.T)
    hidden_layer_gradient = sigmoid_derivative(hlayer_activation)
    hidden_layer_delta = hidden_layer_error * hidden_layer_gradient

    wout += np.dot(hlayer_activation.T, output_delta) * lr
    wh += np.dot(X.T, hidden_layer_delta) * lr

print("Input:\n", X)
print("Actual Output:\n", y)
print("Predicted Output:\n", predicted_output)

4.


            </pre>
            </body>
</html>
